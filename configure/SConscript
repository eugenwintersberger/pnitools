#python module manging the configuration of the sources.
import os

#======================check for nullptr=======================================
#This test checks whether or not the compiler supports the nullptr idiom of
#C++11

def CheckNullPtr(context):
    context.Message("Checking if compiler supports nullptr idiom ...")
    result = context.TryCompile(open('src/nullptr_test.cpp').read(),".cpp")
    context.Result(result)
    return result

#====================check for bind============================================
#Check for std::bind 

def CheckBind(context):
    context.Message("Checking for std::bind function support ...")
    result = context.TryCompile(open('src/bind_test.cpp').read(),".cpp")
    context.Result(result)
    return result


#==============================================================================
##this test checks for lambda-function support of the C++ compiler
#
def CheckLambdaFunctions(context):
    context.Message("Checking for lambda function support ...")
    result = context.TryCompile(open('src/lambda_function_test.cpp').read(),".cpp")
    context.Result(result)
    return result

#==================check for-each construction=================================
#Test checking for for(auto v: container) construction support

def CheckForEach(context):
    context.Message("Check if compiler supports foreach loops ...")
    result = context.TryCompile(open('src/foreach_test.cpp').read(),".cpp")
    context.Result(result)
    return result

#==============================explicit conversion check========================
#Check for explicit conversion operator support

def CheckForExplicitConversion(context):
    context.Message("Check if compiler supports explicit conversion operators ...")
    result = context.TryCompile(open('src/explicit_conversion_test.cpp').read(),".cpp")
    context.Result(result)
    return result

#========================check for C++11 random number facilities==============
#check for random number availability

def CheckForCppRandom(context):
    context.Message("Check for C++ pseudo random number facility ...")
    result = context.TryCompile(open('src/random_test.cpp').read(),".cpp")
    context.Result(result)
    return result

#=======================check for constexpr support============================
#test for constexpr support

def CheckForConstExpr(context):
    context.Message("Check for C++11 constexpr ...")
    result = context.TryCompile(open('src/constexpr_test.cpp').read(),".cpp")
    context.Result(result)
    return result

#=======================check for alias template support=======================
def CheckForTemplateAlias(context):
    context.Message("Check for C++11 alias templates ...")
    result = context.TryCompile(open('src/template_alias_test.cpp').read(),".cpp")
    context.Result(result)
    return result

#=======================check for enum class bug===============================
def CheckForEnumBug(context):
    context.Message("Check for enum bug ...")
    result = context.TryCompile(open('src/enum_bug_test.cpp').read(),".cpp")
    context.Result(result)
    return result

#-------------------------------------------------------------------------------

CustomChecks = {}
CustomChecks["CheckNullPtr"] = CheckNullPtr
CustomChecks["CheckForEach"] = CheckForEach
CustomChecks["CheckExplicitConversion"] = CheckForExplicitConversion
CustomChecks["CheckForCppRandom"] = CheckForCppRandom
CustomChecks["CheckForConstExpr"] = CheckForConstExpr
CustomChecks["CheckForTemplateAlias"] = CheckForTemplateAlias
CustomChecks["CheckForEnumBug"] = CheckForEnumBug
CustomChecks["CheckLambdaFunctions"] = CheckLambdaFunctions
CustomChecks["CheckBind"] = CheckBind

Import('env')
#start with configuration
conf = Configure(env,custom_tests = CustomChecks)


#checking compiler capabilities
#
if not conf.CheckLambdaFunctions():
    print "lambda functions are not supported by this compiler ...!"
    env.AppendUnique(CPPDEFINES=['NO_LAMBDA_FUNC'])

if not conf.CheckBind():
    print "std::bind not supported by this compiler ...!"
    env.AppendUnique(CPPDEFINES=['NO_STD_BIND'])

if not conf.CheckNullPtr():
    print "nullptr not supported - use NULL"
    env.AppendUnique(CPPDEFINES=[('nullptr','NULL')])

if not conf.CheckForEach():
    print "foreach construction not supported - use workaround"
    env.AppendUnique(CPPDEFINES=['NOFOREACH'])

if not conf.CheckExplicitConversion():
    print "explicit conversion not supported by compiler!"
    env.AppendUnique(CPPDEFINES=['NOEXPLICITCONV'])

if not conf.CheckForCppRandom():
    print "No C++11 random number generators!"
    env.AppendUnique(CPPDEFINES=['NOCPPRAND'])

if not conf.CheckForConstExpr():
    print "Compiler does not support constexpr!"
    env.AppendUnique(CPPDEFINES=['NOCEXPR'])

if not conf.CheckForTemplateAlias():
    print "Template aliases not supported!"
    env.AppendUnique(CPPDEFINES=['NOTMPALIAS'])

if not conf.CheckForEnumBug():
    print "Compiler provides no comparsion operators for class enum types!"
    env.AppendUnique(CPPDEFINES=['ENUMBUG'])

#check type sizes
if not conf.CheckTypeSize('int8_t',"#include<cstdint>",language="C++",expect=1):
    print "int8_t size does not fit ..." 
    Exit(1)

if not conf.CheckTypeSize('uint8_t',"#include<cstdint>",language="C++",expect=1):
    print "uint8_t size does not fit ..."
    Exit(1)

if not conf.CheckTypeSize('int16_t',"#include<cstdint>",language="C++",expect=2):
    print "int16_t size does not fit ..."
    Exit(1)

if not conf.CheckTypeSize('uint16_t',"#include<cstdint>",language="C++",expect=2):
    print "uint16_t size does not fit ..."
    Exit(1)

if not conf.CheckTypeSize('int32_t',"#include<cstdint>",language="C++",expect=4):
    print "int32_t size does not fit ..."
    Exit(1)

if not conf.CheckTypeSize('uint32_t',"#include<cstdint>",language="C++",expect=4):
    print "uint32_t size does not fit ..."
    Exit(1)

if not conf.CheckTypeSize('int64_t',"#include<cstdint>",language="C++",expect=8):
    print "int64_t size does not fit ..."
    Exit(1)

if not conf.CheckTypeSize('uint64_t',"#include<cstdint>",language="C++",expect=8):
    print "uint64_t size does not fit ..."
    Exit(1)

if not conf.CheckTypeSize('float',language="C++",expect=4):
    print "float size does not fit ..."
    Exit(1)

if not conf.CheckTypeSize('double',language="C++",expect=8):
    print "double size does not fit ..."
    Exit(1)

if not conf.CheckTypeSize('long double',language="C++",expect = 16):
    #in this case we are on 32Bit PC platform
    if not conf.CheckTypeSize('long double',language="C++",expect=12):
        print "long double size does not fit ..."
        Exit(1)


#check for mandatory header files
if not conf.CheckCXXHeader("boost/numeric/conversion/cast.hpp"):
    print "BOOST header file cast.hpp does not exist!"
    Exit(1)
    
if not conf.CheckCXXHeader("boost/shared_ptr.hpp"):
    print "BOOST header shared_ptr.hpp does not exist!"
    Exit(1)
    
if not conf.CheckCXXHeader("boost/static_assert.hpp"):
    print "BOOST header static_assert.hpp does not exist!"
    Exit(1)
    

if not conf.CheckCXXHeader("boost/regex.hpp"):
    print "Boost regular expressions header file not found!"
    Exit(1)

#check for boost current_function header
if not conf.CheckCXXHeader("boost/current_function.hpp"):
    print "BOOST current_function.hpp not found!"
    Exit(1)

if not conf.CheckCXXHeader("boost/program_options.hpp"):
    print "BOOST program options headers not installed"
    Exit(1)
    

#check for boost regular expressions library
if not conf.CheckLib("boost_regex",language="C++"):
    print "BOOST regular expression library not found"
    Exit(1)

if not conf.CheckLib("boost_program_options",language="C++"):
    print "BOOST program options library not installed!"
    Exit(1)

if not conf.CheckLib("boost_system",language="C++"):
    print "BOOST system library not installed!"
    Exit(1)

if GetOption("with_gperf"):
    if not conf.CheckLib("profiler",language="C++"):
        print "Google CPU profiling library not installed!"
        Exit(1)

    if not conf.CheckLib("tcmalloc",language="C++"):
        print "Google HEAP profiler not installed!"
        Exit(1)


env = conf.Finish()

#create the build environments for the library and the test
build_env = env.Clone()
test_env  = env.Clone()

if ('test' in COMMAND_LINE_TARGETS) or ('test_install' in COMMAND_LINE_TARGETS)\
    or ('benchmarks' in COMMAND_LINE_TARGETS):
    # do nothing in the case that the user has no local PKG_CONFIG_PATH variable
    # set
    try:
        test_env["ENV"]["PKG_CONFIG_PATH"] = os.environ["PKG_CONFIG_PATH"]
    except:
        test_env["ENV"]["PKG_CONFIG_PATH"] = os.path.join(test_env["PREFIX"],"lib","pkgconfig")
        
    try:
        test_env.ParseConfig('pkg-config --cflags --libs pnicore')
    except:
        Exit(1)

    try:
        test_env.ParseConfig('pkg-config --cflags --libs cppunit')
    except:
        Exit(1)

    #============================start configuration for tests=====================
    test_conf = Configure(test_env)

    if not test_conf.CheckCXXHeader("cppunit/TestFixture.h"):
        print "CPPUNIT header TestFixture.h does not exist!"
        Exit(1)
        
    if not test_conf.CheckCXXHeader("cppunit/TestRunner.h"):
        print "CPPUNIT header TestRunner.h does not exist!"
        Exit(1)
        
    if not test_conf.CheckCXXHeader("cppunit/extensions/HelperMacros.h"):
        print "CPPUNIT header HelperMacros.h does not exist!"
        Exit(1)
        
    if not test_conf.CheckCXXHeader("cppunit/TestCaller.h"):
        print "CPPUNIT header TestCaller.h does not exist!"
        Exit(1)
        
    if not test_conf.CheckCXXHeader(["string","cppunit/TestResult.h"]):
        print "CPPUNIT header TestResult.h does not exist!"
        Exit(1)
        
    if not test_conf.CheckCXXHeader("cppunit/TextTestProgressListener.h"):
        print "CPPUNIT header TextTestProgressListener.h does not exist!"
        Exit(1)
        
    if not test_conf.CheckCXXHeader("cppunit/ui/text/TextTestRunner.h"):
        print "CPPUNIT header TextTestRunner.h does not exist!"
        Exit(1)

    #check for mandatory libraries
    if not test_conf.CheckLib("cppunit",language="C++"):
        #check if it is enough to add dl to the linker 
        test_env.AppendUnique(LIBS=["dl"])
        if not test_conf.CheckLib("cppunit",language="C++"):
            print "CPPUNIT unit test libraray is not installed!"
            Exit(1)


    test_env = test_conf.Finish()


Return('build_env test_env')
