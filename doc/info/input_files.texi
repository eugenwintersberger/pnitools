Many programs provided by @b{pnitools} work with data stored in one ore several
files. Most programs expect the names of input files to be passed as 
arguments at the end of their command line call.
Thus, for a single input file a typical command line call can be expected to
look like this

@example
$ prog [OPTIONS] input_file.dat
@end example

@noindent 
If supported by the executing shell, wildcards can be used to pass an
entire list of files to a program. The command line

@example
$ prog [OPTIONS] data/may_2012/exp_*.dat
@end example

@noindent 
will pass all files to the program, whose name matches the pattern
@file{data/may_2012/exp_*.dat}. The latter approach works quite well as long as
the order in which the files are processed by the program does not matter. As
the ordering in which the filenames appear after expansion of the wildcard
depends on the used shell one cannot make any assumptions about it.
There are basically two approaches to handle such cases

@enumerate 
@item
provide a file with the names of the files to process in appropriate order and
pass it to the program via the option @option{--input}
@item
use a format string and a numeric range to determine the input files. 
@end enumerate

@noindent 
The first approach is rather straight forward: write the names of the
files to an ASCII file and pass this file via the @option{--input} to the
program

@example
$ prog --input=input_files.txt [OPTIONS]
@end example

@noindent 
this approach is not only simple to understand it also has the
advantage that the filenames stored in the input file must not match any
particular pattern. You can pass whatever files you want. The obvious drawback
of this method is that one first has to generate the file @file{input_files.txt}
with the filenames. This can become expensive if the number of input files is
large.

Fortunately, many applications that produce a large series of files
use simple file name patterns for their output files. This pattern typically
includes the index of the file in the entire series. 
Usually such files are of the form @file{detector_may_2012_<NUMBER>.dat} where
@emph{<NUMBER>} is the index of the file in the series. All programs in the
@b{pnitools} distribution that accept a series of input files support a special
syntax to handle such cases. The best way to understand this syntax is via an
example like this

@example
$ prog [OPTIONS] detector_may_2012_%05i.dat:100:1000
@end example

@noindent 
The first part of the file series specifier is a C-style format string which
represents the general file name pattern (@file{detector_may_2012_%05i.dat})
where the @verb{|%05i|} is a placeholder for a zero padded 5 digit integer
number. The second part (separated from the format string with a @verb{|:|})
describes an integer range from 100 to 1000. Thus, the above file series
specifier represents a series of files starting with
@file{detector_may_2013_000100.dat} and ending with
@file{detector_may_2012_01000.dat}.  Unlike for ROIs the last index in a file
series range is included in the list. The above file selection can still be
refined using a third argument to the numeric range like in this example

@example
$ prog OPTIONS detector_may_2012_%05i.dat:100:1000:2
@end example

@noindent
This will basically produce the same list of filenames but but with a stride of
2 in the numbers meaning

@example
detector_may_2012_00100.dat
detector_may_2012_00102.dat
detector_may_2012_00104.dat
.....
@end example

@noindent
With this one would be able to omit dark-field images recorded after every
sample image.

